{"version":3,"file":"context-container.js","sourceRoot":"","sources":["../../../src/lib/controllers/context-container.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAcH;;;;;;;GAOG;AACH,MAAM,OAAO,gBAAgB;IAsB3B,YAAY,YAAgB;QArBpB,cAAS,GAA2B,IAAI,GAAG,EAAE,CAAC;QA2BtD,kBAAa,GAAG,GAAS,EAAE;YACzB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE,EAAE,CAC9C,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,CAChC,CAAC;QACJ,CAAC,CAAC;QATA,IAAI,YAAY,KAAK,SAAS,EAAE;YAC9B,IAAI,CAAC,KAAK,GAAG,YAAY,CAAC;SAC3B;IACH,CAAC;IAtBD,IAAW,KAAK;QACd,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IACD,IAAW,KAAK,CAAC,CAAI;QACnB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IACnB,CAAC;IAEM,QAAQ,CAAC,CAAI,EAAE,KAAK,GAAG,KAAK;QACjC,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM,EAAE;YACrB,OAAO,GAAG,IAAI,CAAC;SAChB;QACD,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAChB,IAAI,OAAO,IAAI,KAAK,EAAE;YACpB,IAAI,CAAC,aAAa,EAAE,CAAC;SACtB;IACH,CAAC;IAcD,WAAW,CAAC,QAA4B,EAAE,QAAkB;QAC1D,IAAI,QAAQ,EAAE;YACZ,MAAM,MAAM,GAAsB;gBAChC,QAAQ;gBACR,GAAG,EAAE;oBACH,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;gBAChC,CAAC;aACF,CAAC;YACF,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;SAC5B;QACD,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACvB,CAAC;IAED,cAAc;QACZ,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;IACzB,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextCallback} from '../context-event.js';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\n/**\n * A tuple of context callback, and its disposer\n */\ntype CallbackRecord<T> = [ContextCallback<T>, Disposer];\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when the\n * value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to get\n * behavior like this. But this is a pretty minimal approach that will likely work\n * for a number of use cases.\n */\nexport class ContextContainer<T> {\n  private callbacks: Set<CallbackRecord<T>> = new Set();\n\n  private _value!: T;\n  public get value(): T {\n    return this._value;\n  }\n  public set value(v: T) {\n    this.setValue(v);\n  }\n\n  public setValue(v: T, force = false) {\n    let changed = false;\n    if (v !== this._value) {\n      changed = true;\n    }\n    this._value = v;\n    if (changed || force) {\n      this.updateContext();\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  updateContext = (): void => {\n    this.callbacks.forEach(([callback, disposer]) =>\n      callback(this._value, disposer)\n    );\n  };\n\n  addCallback(callback: ContextCallback<T>, multiple?: boolean): void {\n    if (multiple) {\n      const record: CallbackRecord<T> = [\n        callback,\n        () => {\n          this.callbacks.delete(record);\n        },\n      ];\n      this.callbacks.add(record);\n    }\n    callback(this.value);\n  }\n\n  clearCallbacks(): void {\n    this.callbacks.clear();\n  }\n}\n"]}
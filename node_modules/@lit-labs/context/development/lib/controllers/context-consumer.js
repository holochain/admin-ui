/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { ContextEvent } from "../context-event.js";
/**
 * ContextConsumer is a ReactiveController which binds a custom-element's
 * lifecycle to the Context API. When an element is connected to the DOM it
 * will emit the context-request event, invoking the callback set on the
 * controller when the context request is satisfied. It will also call
 * the dispose method provided by the Context API when the element is
 * disconnected.
 */
export class ContextConsumer {
    constructor(host, context, callback, multiple = false) {
        this.host = host;
        this.context = context;
        this.callback = callback;
        this.multiple = multiple;
        this.provided = false;
        this.captured = false;
        this.host.addController(this);
    }
    hostConnected() {
        // We are setting the timeout here to prevent the event from firing before the context container has connected
        // This happens if the context consumer is in slotted inside the light DOM of the context container
        this.tryToConnect();
        setTimeout(() => {
            this.tryToConnect();
        });
    }
    hostUpdate() {
        this.tryToConnect();
    }
    tryToConnect() {
        if (this.captured)
            return;
        const event = new ContextEvent(this.context, (value, dispose) => {
            // some providers will pass a dispose function indicating they may provide future values
            if (this.dispose) {
                // if the dispose function changes this implies we have changed provider
                if (this.dispose !== dispose) {
                    // cleanup the old provider
                    this.dispose();
                }
                // if we don't support multiple values, immediately dispose
                if (!this.multiple) {
                    this.dispose();
                }
            }
            // only invoke callback if we are either expecting multiple or have not yet
            // been provided a value
            if (!this.provided || this.multiple) {
                this.provided = true;
                this.callback(value, dispose);
            }
            this.dispose = dispose;
        }, this.multiple);
        this.host.dispatchEvent(event);
        this.captured = event.captured;
    }
    hostDisconnected() {
        if (this.dispose) {
            this.dispose();
            this.dispose = undefined;
        }
    }
}
//# sourceMappingURL=context-consumer.js.map
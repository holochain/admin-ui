{"version":3,"file":"context-consumer.js","sourceRoot":"","sources":["../../../src/lib/controllers/context-consumer.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAC;AAInD;;;;;;;GAOG;AACH,MAAM,OAAO,eAAe;IAM1B,YACY,IAAiB,EACnB,OAAqB,EACrB,QAGC,EACD,WAAoB,KAAK;QANvB,SAAI,GAAJ,IAAI,CAAa;QACnB,YAAO,GAAP,OAAO,CAAc;QACrB,aAAQ,GAAR,QAAQ,CAGP;QACD,aAAQ,GAAR,QAAQ,CAAiB;QAV3B,aAAQ,GAAG,KAAK,CAAC;QACjB,aAAQ,GAAG,KAAK,CAAC;QAWvB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAID,aAAa;QACX,8GAA8G;QAC9G,mGAAmG;QACnG,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,UAAU,CAAC,GAAG,EAAE;YACd,IAAI,CAAC,YAAY,EAAE,CAAC;QACtB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,UAAU;QACR,IAAI,CAAC,YAAY,EAAE,CAAC;IACtB,CAAC;IAED,YAAY;QACV,IAAI,IAAI,CAAC,QAAQ;YAAE,OAAO;QAE1B,MAAM,KAAK,GAAG,IAAI,YAAY,CAC5B,IAAI,CAAC,OAAO,EACZ,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE;YACjB,wFAAwF;YACxF,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChB,wEAAwE;gBACxE,IAAI,IAAI,CAAC,OAAO,KAAK,OAAO,EAAE;oBAC5B,2BAA2B;oBAC3B,IAAI,CAAC,OAAO,EAAE,CAAC;iBAChB;gBACD,2DAA2D;gBAC3D,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;oBAClB,IAAI,CAAC,OAAO,EAAE,CAAC;iBAChB;aACF;YAED,2EAA2E;YAC3E,wBAAwB;YACxB,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACnC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;gBACrB,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;aAC/B;YAED,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACzB,CAAC,EACD,IAAI,CAAC,QAAQ,CACd,CAAC;QAEF,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAE/B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;IACjC,CAAC;IAED,gBAAgB;QACd,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;SAC1B;IACH,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport { ContextEvent } from \"../context-event.js\";\nimport { Context, ContextType } from \"../create-context.js\";\nimport { ReactiveController, ReactiveElement } from \"lit\";\n\n/**\n * ContextConsumer is a ReactiveController which binds a custom-element's\n * lifecycle to the Context API. When an element is connected to the DOM it\n * will emit the context-request event, invoking the callback set on the\n * controller when the context request is satisfied. It will also call\n * the dispose method provided by the Context API when the element is\n * disconnected.\n */\nexport class ContextConsumer<Ctx, HostElement extends ReactiveElement>\n  implements ReactiveController\n{\n  private provided = false;\n  private captured = false;\n\n  constructor(\n    protected host: HostElement,\n    private context: Context<Ctx>,\n    private callback: (\n      value: ContextType<Context<Ctx>>,\n      dispose?: () => void\n    ) => void,\n    private multiple: boolean = false\n  ) {\n    this.host.addController(this);\n  }\n\n  private dispose?: () => void;\n\n  hostConnected(): void {\n    // We are setting the timeout here to prevent the event from firing before the context container has connected\n    // This happens if the context consumer is in slotted inside the light DOM of the context container\n    this.tryToConnect();\n    setTimeout(() => {\n      this.tryToConnect();\n    });\n  }\n\n  hostUpdate() {\n    this.tryToConnect();\n  }\n\n  tryToConnect() {\n    if (this.captured) return;\n\n    const event = new ContextEvent(\n      this.context,\n      (value, dispose) => {\n        // some providers will pass a dispose function indicating they may provide future values\n        if (this.dispose) {\n          // if the dispose function changes this implies we have changed provider\n          if (this.dispose !== dispose) {\n            // cleanup the old provider\n            this.dispose();\n          }\n          // if we don't support multiple values, immediately dispose\n          if (!this.multiple) {\n            this.dispose();\n          }\n        }\n\n        // only invoke callback if we are either expecting multiple or have not yet\n        // been provided a value\n        if (!this.provided || this.multiple) {\n          this.provided = true;\n          this.callback(value, dispose);\n        }\n\n        this.dispose = dispose;\n      },\n      this.multiple\n    );\n\n    this.host.dispatchEvent(event);\n\n    this.captured = event.captured;\n  }\n\n  hostDisconnected(): void {\n    if (this.dispose) {\n      this.dispose();\n      this.dispose = undefined;\n    }\n  }\n}\n"]}
{"version":3,"file":"context-consumer.js","sources":["../../src/lib/controllers/context-consumer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport { ContextEvent } from \"../context-event.js\";\nimport { Context, ContextType } from \"../create-context.js\";\nimport { ReactiveController, ReactiveElement } from \"lit\";\n\n/**\n * ContextConsumer is a ReactiveController which binds a custom-element's\n * lifecycle to the Context API. When an element is connected to the DOM it\n * will emit the context-request event, invoking the callback set on the\n * controller when the context request is satisfied. It will also call\n * the dispose method provided by the Context API when the element is\n * disconnected.\n */\nexport class ContextConsumer<Ctx, HostElement extends ReactiveElement>\n  implements ReactiveController\n{\n  private provided = false;\n  private captured = false;\n\n  constructor(\n    protected host: HostElement,\n    private context: Context<Ctx>,\n    private callback: (\n      value: ContextType<Context<Ctx>>,\n      dispose?: () => void\n    ) => void,\n    private multiple: boolean = false\n  ) {\n    this.host.addController(this);\n  }\n\n  private dispose?: () => void;\n\n  hostConnected(): void {\n    // We are setting the timeout here to prevent the event from firing before the context container has connected\n    // This happens if the context consumer is in slotted inside the light DOM of the context container\n    this.tryToConnect();\n    setTimeout(() => {\n      this.tryToConnect();\n    });\n  }\n\n  hostUpdate() {\n    this.tryToConnect();\n  }\n\n  tryToConnect() {\n    if (this.captured) return;\n\n    const event = new ContextEvent(\n      this.context,\n      (value, dispose) => {\n        // some providers will pass a dispose function indicating they may provide future values\n        if (this.dispose) {\n          // if the dispose function changes this implies we have changed provider\n          if (this.dispose !== dispose) {\n            // cleanup the old provider\n            this.dispose();\n          }\n          // if we don't support multiple values, immediately dispose\n          if (!this.multiple) {\n            this.dispose();\n          }\n        }\n\n        // only invoke callback if we are either expecting multiple or have not yet\n        // been provided a value\n        if (!this.provided || this.multiple) {\n          this.provided = true;\n          this.callback(value, dispose);\n        }\n\n        this.dispose = dispose;\n      },\n      this.multiple\n    );\n\n    this.host.dispatchEvent(event);\n\n    this.captured = event.captured;\n  }\n\n  hostDisconnected(): void {\n    if (this.dispose) {\n      this.dispose();\n      this.dispose = undefined;\n    }\n  }\n}\n"],"names":["ContextConsumer","constructor","host","context","callback","multiple","this","addController","hostConnected","tryToConnect","setTimeout","hostUpdate","captured","event","ContextEvent","value","dispose","provided","dispatchEvent","hostDisconnected","undefined"],"mappings":";;;;;SAkBaA,EAMXC,YACYC,EACFC,EACAC,EAIAC,GAAoB,GANlBC,UAAAJ,EACFI,aAAAH,EACAG,cAAAF,EAIAE,cAAAD,EAVFC,eAAW,EACXA,eAAW,EAWjBA,KAAKJ,KAAKK,cAAcD,MAK1BE,gBAGEF,KAAKG,eACLC,YAAW,KACTJ,KAAKG,kBAITE,aACEL,KAAKG,eAGPA,eACE,GAAIH,KAAKM,SAAU,OAEnB,MAAMC,EAAQ,IAAIC,EAChBR,KAAKH,SACL,CAACY,EAAOC,KAEFV,KAAKU,UAEHV,KAAKU,UAAYA,GAEnBV,KAAKU,UAGFV,KAAKD,UACRC,KAAKU,WAMJV,KAAKW,WAAYX,KAAKD,WACzBC,KAAKW,UAAW,EAChBX,KAAKF,SAASW,EAAOC,IAGvBV,KAAKU,QAAUA,IAEjBV,KAAKD,UAGPC,KAAKJ,KAAKgB,cAAcL,GAExBP,KAAKM,SAAWC,EAAMD,SAGxBO,mBACMb,KAAKU,UACPV,KAAKU,UACLV,KAAKU,aAAUI"}
{"version":3,"file":"context-container.js","sources":["../../src/lib/controllers/context-container.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextCallback} from '../context-event.js';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\n/**\n * A tuple of context callback, and its disposer\n */\ntype CallbackRecord<T> = [ContextCallback<T>, Disposer];\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when the\n * value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to get\n * behavior like this. But this is a pretty minimal approach that will likely work\n * for a number of use cases.\n */\nexport class ContextContainer<T> {\n  private callbacks: Set<CallbackRecord<T>> = new Set();\n\n  private _value!: T;\n  public get value(): T {\n    return this._value;\n  }\n  public set value(v: T) {\n    this.setValue(v);\n  }\n\n  public setValue(v: T, force = false) {\n    let changed = false;\n    if (v !== this._value) {\n      changed = true;\n    }\n    this._value = v;\n    if (changed || force) {\n      this.updateContext();\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  updateContext = (): void => {\n    this.callbacks.forEach(([callback, disposer]) =>\n      callback(this._value, disposer)\n    );\n  };\n\n  addCallback(callback: ContextCallback<T>, multiple?: boolean): void {\n    if (multiple) {\n      const record: CallbackRecord<T> = [\n        callback,\n        () => {\n          this.callbacks.delete(record);\n        },\n      ];\n      this.callbacks.add(record);\n    }\n    callback(this.value);\n  }\n\n  clearCallbacks(): void {\n    this.callbacks.clear();\n  }\n}\n"],"names":["ContextContainer","constructor","defaultValue","this","Set","callbacks","forEach","callback","disposer","_value","undefined","value","v","setValue","force","changed","updateContext","addCallback","multiple","record","delete","add","clearCallbacks","clear"],"mappings":";;;;;MA0BaA,EAsBXC,YAAYC,GArBJC,eAAoC,IAAIC,IA2BhDD,mBAAgB,KACdA,KAAKE,UAAUC,SAAQ,EAAEC,EAAUC,KACjCD,EAASJ,KAAKM,EAAQD,WAPHE,IAAjBR,IACFC,KAAKQ,MAAQT,GApBjBS,YACE,OAAOR,KAAKM,EAEdE,UAAiBC,GACfT,KAAKU,SAASD,GAGTC,SAASD,EAAME,GAAQ,GAC5B,IAAIC,GAAU,EACVH,IAAMT,KAAKM,IACbM,GAAU,GAEZZ,KAAKM,EAASG,GACVG,GAAWD,IACbX,KAAKa,gBAgBTC,YAAYV,EAA8BW,GACxC,GAAIA,EAAU,CACZ,MAAMC,EAA4B,CAChCZ,EACA,KACEJ,KAAKE,UAAUe,OAAOD,KAG1BhB,KAAKE,UAAUgB,IAAIF,GAErBZ,EAASJ,KAAKQ,OAGhBW,iBACEnB,KAAKE,UAAUkB"}
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyStore = exports.createKeyStoreKey = void 0;
const ton_crypto_1 = require("ton-crypto");
const t = __importStar(require("io-ts"));
const Either_1 = require("fp-ts/lib/Either");
const __1 = require("..");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const codec = t.type({
    version: t.number,
    salt: t.string,
    publicKey: t.string,
    records: t.array(t.type({
        name: t.string,
        address: t.string,
        kind: t.string,
        config: t.string,
        publicKey: t.string,
        secretKey: t.string,
        comment: t.string
    }))
});
async function createKeyStoreKey(password, salt) {
    let secretKey = await (0, ton_crypto_1.pbkdf2_sha512)(password, salt, 400000, 32);
    let r = tweetnacl_1.default.box.keyPair.fromSecretKey(secretKey);
    return {
        secretKey: Buffer.from(r.secretKey),
        publicKey: Buffer.from(r.publicKey)
    };
}
exports.createKeyStoreKey = createKeyStoreKey;
class KeyStore {
    static async createNew(password) {
        let salt = await (0, ton_crypto_1.getSecureRandomBytes)(32);
        let key = await createKeyStoreKey(password, salt);
        return new KeyStore({ version: 1, salt: salt.toString('hex'), publicKey: key.publicKey.toString('hex'), records: [] });
    }
    static async load(source) {
        // Validate checksum
        if (source.length < 32) {
            throw Error('Broken keystore');
        }
        let hash = source.slice(0, 32);
        let data = source.slice(32);
        let hash2 = await (0, ton_crypto_1.sha256)(data);
        if (!hash.equals(hash2)) { // We don't care about timing attacks here
            throw Error('Broken keystore');
        }
        // Parse storage
        let parsed = JSON.parse(data.toString('utf-8'));
        let decoded = codec.decode(parsed);
        if ((0, Either_1.isLeft)(decoded)) {
            throw Error('Broken keystore');
        }
        return new KeyStore(decoded.right);
    }
    #salt;
    #publicKey;
    #records = new Map();
    constructor(src) {
        if (src.version !== 1) {
            throw Error('Unsupported keystore');
        }
        this.#salt = src.salt;
        this.#publicKey = src.publicKey;
        for (let r of src.records) {
            if (this.#records.has(r.name)) {
                throw Error('Broken keystore');
            }
            const record = {
                name: r.name,
                address: __1.Address.parseRaw(r.address),
                kind: r.kind,
                config: r.config,
                comment: r.comment,
                publicKey: r.publicKey,
                secretKey: r.secretKey
            };
            Object.freeze(record);
            this.#records.set(r.name, record);
        }
    }
    get allKeys() {
        let res = [];
        for (let k of this.#records.keys()) {
            let r = this.#records.get(k);
            res.push({
                name: r.name,
                address: r.address,
                kind: r.kind,
                config: r.config,
                comment: r.comment,
                publicKey: Buffer.from(r.publicKey, 'hex')
            });
        }
        return res;
    }
    checkPassword = async (password) => {
        let key = await createKeyStoreKey(password, Buffer.from(this.#salt, 'hex'));
        if (!key.publicKey.equals(Buffer.from(this.#publicKey, 'hex'))) {
            return false;
        }
        else {
            return true;
        }
    };
    hasKey = (name) => {
        return this.#records.has(name);
    };
    getKey = (name) => {
        let ex = this.#records.get(name);
        if (ex) {
            return {
                name: ex.name,
                address: ex.address,
                kind: ex.kind,
                config: ex.config,
                comment: ex.comment,
                publicKey: Buffer.from(ex.publicKey, 'hex')
            };
        }
        return null;
    };
    getSecret = async (name, password) => {
        if (!this.#records.has(name)) {
            throw Error('Key with name ' + name + ' does not exist');
        }
        let record = this.#records.get(name);
        let src = Buffer.from(record.secretKey, 'hex');
        let nonce = src.slice(0, 24);
        let publicKey = src.slice(24, 24 + 32);
        let data = src.slice(24 + 32);
        // Derive key
        let key = await createKeyStoreKey(password, Buffer.from(this.#salt, 'hex'));
        if (!key.publicKey.equals(Buffer.from(this.#publicKey, 'hex'))) {
            throw Error('Invalid password');
        }
        // Decode
        let decoded = tweetnacl_1.default.box.open(data, nonce, publicKey, key.secretKey);
        if (!decoded) {
            throw Error('Invalid password');
        }
        return Buffer.from(decoded);
    };
    addKey = async (record, key) => {
        if (this.#records.has(record.name)) {
            throw Error('Key with name ' + record.name + ' already exists');
        }
        // Create key
        let ephemeralKeySecret = await (0, ton_crypto_1.getSecureRandomBytes)(32);
        let ephemeralKeyPublic = Buffer.from((tweetnacl_1.default.box.keyPair.fromSecretKey(ephemeralKeySecret)).publicKey);
        let nonce = await (0, ton_crypto_1.getSecureRandomBytes)(24);
        let encrypted = tweetnacl_1.default.box(key, nonce, Buffer.from(this.#publicKey, 'hex'), ephemeralKeySecret);
        let data = Buffer.concat([nonce, ephemeralKeyPublic, encrypted]);
        // Create record
        let rec = {
            name: record.name,
            address: record.address,
            kind: record.kind,
            config: record.config,
            comment: record.comment,
            publicKey: record.publicKey.toString('hex'),
            secretKey: data.toString('hex')
        };
        Object.freeze(rec);
        this.#records.set(record.name, rec);
    };
    removeKey = (name) => {
        if (!this.#records.has(name)) {
            throw Error('Key with name ' + name + ' does not exist');
        }
        this.#records.delete(name);
    };
    async save() {
        let store = {
            version: 1,
            salt: this.#salt,
            publicKey: this.#publicKey,
            records: Array.from(this.#records.entries()).map((v) => ({
                name: v[1].name,
                address: v[1].address.toString(),
                kind: v[1].kind,
                config: v[1].config,
                comment: v[1].comment,
                publicKey: v[1].publicKey,
                secretKey: v[1].secretKey
            }))
        };
        let data = Buffer.from(JSON.stringify(store), 'utf-8');
        let hash = await (0, ton_crypto_1.sha256)(data);
        return Buffer.concat([hash, data]);
    }
}
exports.KeyStore = KeyStore;

/// <reference types="bn.js" />
/// <reference types="node" />
import { Address } from "../address/Address";
import { Message } from "../messages/Message";
import { Cell } from "../boc/Cell";
import { Contract } from "../contracts/Contract";
import { Wallet } from "./Wallet";
import { ElectorContract } from "../contracts/ElectorContract";
import { Maybe } from '../types';
export declare type TonClientParameters = {
    endpoint: string;
};
export declare class TonClient {
    #private;
    readonly parameters: TonClientParameters;
    services: {
        elector: ElectorContract;
    };
    constructor(parameters: TonClientParameters);
    /**
     * Get Address Balance
     * @param address address for balance check
     * @returns balance
     */
    getBalance(address: Address): Promise<import("bn.js")>;
    /**
     * Invoke get method
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     */
    callGetMethod(address: Address, name: string, params?: any[]): Promise<{
        gas_used: number;
        stack: any[];
    }>;
    /**
     * Send message to a network
     * @param src source message
     */
    sendMessage(src: Message): Promise<void>;
    /**
     * Send external message to contract
     * @param contract contract to send message
     * @param src message body
     */
    sendExternalMessage(contract: Contract, src: Cell): Promise<void>;
    /**
     * Check if contract is deployed
     * @param address addres to check
     * @returns true if contract is in active state
     */
    isContractDeployed(address: Address): Promise<boolean>;
    /**
     * Resolves contract state
     * @param address contract address
     */
    getContractState(address: Address): Promise<{
        balance: import("bn.js");
        state: "active" | "uninitialized" | "frozen";
    }>;
    /**
     * Open Wallet from address
     * @param source wallet address
     * @returns wallet with specified address
     */
    openWalletFromAddress(args: {
        source: Address;
    }): Promise<Wallet>;
    /**
     * Open Wallet from secret key. Searches for best wallet contract.
     * @param workchain wallet workchain
     * @param secretKey wallet secret key
     * @returns best matched wallet
     */
    openWalletFromSecretKey(args: {
        workchain: number;
        secretKey: Buffer;
    }): Promise<Wallet>;
    /**
     * Open wallet with default contract
     * @param args workchain and secret key
     * @returns wallet
     */
    openWalletDefaultFromSecretKey(args: {
        workchain: number;
        secretKey: Buffer;
    }): Promise<Wallet>;
    /**
     * Securely creates new wallet
     * @param password optional password
     */
    createNewWallet(args: {
        workchain: number;
        password?: Maybe<string>;
    }): Promise<{
        mnemonic: string[];
        key: import("ton-crypto").KeyPair;
        wallet: Wallet;
    }>;
}

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const ton_crypto_1 = require("ton-crypto");
const WalletV1R2Source_1 = require("../contracts/sources/WalletV1R2Source");
const WalletV1R3Source_1 = require("../contracts/sources/WalletV1R3Source");
const WalletV2R1Source_1 = require("../contracts/sources/WalletV2R1Source");
const WalletV2R2Source_1 = require("../contracts/sources/WalletV2R2Source");
const WalletV3R1Source_1 = require("../contracts/sources/WalletV3R1Source");
const WalletV3R2Source_1 = require("../contracts/sources/WalletV3R2Source");
const WalletContract_1 = require("../contracts/WalletContract");
const CommonMessageInfo_1 = require("../messages/CommonMessageInfo");
const InternalMessage_1 = require("../messages/InternalMessage");
// Wallet Contract Priority
const allTypes = [
    'org.ton.wallets.simple.r2',
    'org.ton.wallets.simple.r3',
    'org.ton.wallets.v2',
    'org.ton.wallets.v2.r2',
    'org.ton.wallets.v3.r2',
    'org.ton.wallets.v3'
];
async function createContract(client, type, publicKey, workchain) {
    if (type === 'org.ton.wallets.simple') {
        throw Error('Unsupported wallet');
    }
    else if (type === 'org.ton.wallets.simple.r2') {
        return await WalletContract_1.WalletContract.create(client, WalletV1R2Source_1.WalletV1R2Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.simple.r3') {
        return await WalletContract_1.WalletContract.create(client, WalletV1R3Source_1.WalletV1R3Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.v2') {
        return await WalletContract_1.WalletContract.create(client, WalletV2R1Source_1.WalletV2R1Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.v2.r2') {
        return await WalletContract_1.WalletContract.create(client, WalletV2R2Source_1.WalletV2R2Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.v3') {
        return await WalletContract_1.WalletContract.create(client, WalletV3R1Source_1.WalletV3R1Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.v3.r2') {
        return await WalletContract_1.WalletContract.create(client, WalletV3R2Source_1.WalletV3R2Source.create({ publicKey, workchain }));
    }
    else {
        throw Error('Unknown wallet type: ' + type);
    }
}
class Wallet {
    static open(client, address) {
        return new Wallet(client, address);
    }
    static async openDefault(client, workchain, secretKey) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let c = await createContract(client, 'org.ton.wallets.v3', publicKey, workchain);
        let w = new Wallet(client, c.address);
        await w.prepare(workchain, publicKey, 'org.ton.wallets.v3');
        return w;
    }
    static async findActiveBySecretKey(client, workchain, secretKey) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let types = [];
        for (let type of allTypes) {
            let contra = await createContract(client, type, publicKey, workchain);
            let deployed = await client.isContractDeployed(contra.address);
            let balance = await client.getBalance(contra.address);
            if (deployed || balance.gt(new bn_js_1.default(0))) {
                types.push({ address: contra.address, type, balance, deployed });
            }
        }
        return types;
    }
    static async findBestBySecretKey(client, workchain, secretKey) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let allActive = await this.findActiveBySecretKey(client, workchain, secretKey);
        // Create default one if no wallet exists
        if (allActive.length === 0) {
            return this.openDefault(client, workchain, secretKey);
        }
        // Try to match with biggest balance
        let maxBalance = allActive[0].balance;
        let bestContract = allActive[0].type;
        for (let i = 1; i < allActive.length; i++) {
            let ac = allActive[i];
            // Contracts are sorted by priority
            if (ac.balance.gte(maxBalance)) {
                maxBalance = ac.balance;
                bestContract = ac.type;
            }
        }
        if (maxBalance.gt(new bn_js_1.default(0))) {
            let c = await createContract(client, bestContract, publicKey, workchain);
            ;
            let w = new Wallet(client, c.address);
            await w.prepare(workchain, publicKey, bestContract);
            return w;
        }
        // Return last (as most recent)
        let c = await createContract(client, allActive[allActive.length - 1].type, publicKey, workchain);
        let w = new Wallet(client, c.address);
        await w.prepare(workchain, publicKey, allActive[allActive.length - 1].type);
        return w;
    }
    #client;
    address;
    #contract = null;
    get prepared() {
        return !!this.#contract;
    }
    constructor(client, address) {
        this.#client = client;
        this.address = address;
    }
    async getSeqNo() {
        if (await this.#client.isContractDeployed(this.address)) {
            let res = await this.#client.callGetMethod(this.address, 'seqno');
            return parseInt(res.stack[0][1], 16);
        }
        else {
            return 0;
        }
    }
    async prepare(workchain, publicKey, type = 'org.ton.wallets.v3') {
        let contra = await createContract(this.#client, type, publicKey, workchain);
        if (!contra.address.equals(this.address)) {
            throw Error('Contract have different address');
        }
        this.#contract = contra;
    }
    /**
     * Transfers value to specified address
     */
    async transfer(args) {
        const contract = this.#contract;
        if (!contract) {
            throw Error('Please, prepare wallet first');
        }
        // Check transfer
        const transfer = await contract.createTransfer({
            secretKey: args.secretKey,
            seqno: args.seqno,
            sendMode: 3,
            order: new InternalMessage_1.InternalMessage({
                to: args.to,
                value: args.value,
                bounce: args.bounce,
                body: new CommonMessageInfo_1.CommonMessageInfo()
            })
        });
        // Send
        await this.#client.sendExternalMessage(contract, transfer);
    }
    /**
     * Signing transfer request. Could be done offline.
     * @param args sign
     * @returns
     */
    async transferSign(args) {
        const contract = this.#contract;
        if (!contract) {
            throw Error('Please, prepare wallet first');
        }
        const transfer = await contract.createTransfer({
            secretKey: args.secretKey,
            seqno: args.seqno,
            sendMode: 3,
            order: new InternalMessage_1.InternalMessage({
                to: args.to,
                value: args.value,
                bounce: args.bounce,
                body: new CommonMessageInfo_1.CommonMessageInfo()
            })
        });
        return transfer;
    }
    /**
     * Commit prepared transfer
     * @param transfer signed transfer for commit
     */
    async transferCommit(transfer) {
        const contract = this.#contract;
        if (!contract) {
            throw Error('Please, prepare wallet first');
        }
        await this.#client.sendExternalMessage(contract, transfer);
    }
}
exports.Wallet = Wallet;

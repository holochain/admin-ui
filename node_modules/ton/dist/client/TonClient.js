"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonClient = void 0;
const ton_crypto_1 = require("ton-crypto");
const Cell_1 = require("../boc/Cell");
const HttpApi_1 = require("./api/HttpApi");
const ExternalMessage_1 = require("../messages/ExternalMessage");
const CommonMessageInfo_1 = require("../messages/CommonMessageInfo");
const StateInit_1 = require("../messages/StateInit");
const RawMessage_1 = require("../messages/RawMessage");
const Wallet_1 = require("./Wallet");
const ElectorContract_1 = require("../contracts/ElectorContract");
const bn_js_1 = require("bn.js");
class TonClient {
    parameters;
    #api;
    services = {
        elector: new ElectorContract_1.ElectorContract(this)
    };
    constructor(parameters) {
        this.parameters = parameters;
        this.#api = new HttpApi_1.HttpApi(parameters.endpoint);
    }
    /**
     * Get Address Balance
     * @param address address for balance check
     * @returns balance
     */
    async getBalance(address) {
        return (await this.getContractState(address)).balance;
    }
    /**
     * Invoke get method
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     */
    async callGetMethod(address, name, params = []) {
        let res = await this.#api.callGetMethod(address, name, params);
        if (res.exit_code !== 0) {
            throw Error('Unable to execute get method. Got exit_code: ' + res.exit_code);
        }
        return { gas_used: res.gas_used, stack: res.stack };
    }
    /**
     * Send message to a network
     * @param src source message
     */
    async sendMessage(src) {
        const cell = new Cell_1.Cell();
        src.writeTo(cell);
        const boc = await cell.toBoc({ idx: false });
        await this.#api.sendBoc(boc);
    }
    /**
     * Send external message to contract
     * @param contract contract to send message
     * @param src message body
     */
    async sendExternalMessage(contract, src) {
        if (await this.isContractDeployed(contract.address)) {
            const message = new ExternalMessage_1.ExternalMessage({
                to: contract.address,
                body: new CommonMessageInfo_1.CommonMessageInfo({
                    body: new RawMessage_1.RawMessage(src)
                })
            });
            await this.sendMessage(message);
        }
        else {
            const message = new ExternalMessage_1.ExternalMessage({
                to: contract.address,
                body: new CommonMessageInfo_1.CommonMessageInfo({
                    stateInit: new StateInit_1.StateInit({ code: contract.source.initialCode, data: contract.source.initialData }),
                    body: new RawMessage_1.RawMessage(src)
                })
            });
            await this.sendMessage(message);
        }
    }
    /**
     * Check if contract is deployed
     * @param address addres to check
     * @returns true if contract is in active state
     */
    async isContractDeployed(address) {
        return (await this.getContractState(address)).state === 'active';
    }
    /**
     * Resolves contract state
     * @param address contract address
     */
    async getContractState(address) {
        let info = await this.#api.getAddressInformation(address);
        let balance = new bn_js_1.BN(info.balance);
        let state = info.state;
        return {
            balance,
            state
        };
    }
    /**
     * Open Wallet from address
     * @param source wallet address
     * @returns wallet with specified address
     */
    async openWalletFromAddress(args) {
        return Wallet_1.Wallet.open(this, args.source);
    }
    /**
     * Open Wallet from secret key. Searches for best wallet contract.
     * @param workchain wallet workchain
     * @param secretKey wallet secret key
     * @returns best matched wallet
     */
    async openWalletFromSecretKey(args) {
        return Wallet_1.Wallet.findBestBySecretKey(this, args.workchain, args.secretKey);
    }
    /**
     * Open wallet with default contract
     * @param args workchain and secret key
     * @returns wallet
     */
    async openWalletDefaultFromSecretKey(args) {
        return Wallet_1.Wallet.openDefault(this, args.workchain, args.secretKey);
    }
    /**
     * Securely creates new wallet
     * @param password optional password
     */
    async createNewWallet(args) {
        let mnemonic = await (0, ton_crypto_1.mnemonicNew)(24, args.password);
        let key = await (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic, args.password);
        let wallet = await Wallet_1.Wallet.openDefault(this, args.workchain, key.secretKey);
        return {
            mnemonic,
            key,
            wallet
        };
    }
}
exports.TonClient = TonClient;

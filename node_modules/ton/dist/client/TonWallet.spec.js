"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
jest.setTimeout(20000);
const __1 = require("..");
const createTestClient_1 = require("../tests/createTestClient");
const openTestTreasure_1 = require("../tests/openTestTreasure");
const time_1 = require("../utils/time");
describe('TonWallet', () => {
    it('should throw on when trying to get seqno of unintitialized contract', async () => {
        const client = await (0, createTestClient_1.createTestClient)();
        const wallet = await client.createWallet();
        await expect(wallet.wallet.getSeqNo()).rejects.toThrowError();
    });
    it('should return valid seq no on initialized contract', async () => {
        const client = await (0, createTestClient_1.createTestClient)();
        let treasure = await (0, openTestTreasure_1.openTestTreasure)(client);
        let seqno = await treasure.wallet.getSeqNo();
        expect(seqno).toBeGreaterThan(5);
    });
    it('should trasnfer', async () => {
        const client = await (0, createTestClient_1.createTestClient)();
        let treasure = await (0, openTestTreasure_1.openTestTreasure)(client);
        let dest = __1.Address.parseFriendly('EQClZ-KEDodcnyoyPX7c0qBBQ9QePzzquVwKuaqHk7F01825').address;
        let balance = await client.getBalance(dest);
        let seqno = await treasure.wallet.getSeqNo();
        await treasure.wallet.transfer({
            to: dest,
            value: 0.001,
            bounceable: false,
            seqno,
            secretKey: treasure.secretKey
        });
        while (true) {
            await (0, time_1.delay)(1000);
            if (await client.getBalance(dest) > balance) {
                break;
            }
        }
    });
    it('should trasnfer by stages', async () => {
        const client = await (0, createTestClient_1.createTestClient)();
        let treasure = await (0, openTestTreasure_1.openTestTreasure)(client);
        let dest = __1.Address.parseFriendly('EQClZ-KEDodcnyoyPX7c0qBBQ9QePzzquVwKuaqHk7F01825').address;
        let balance = await client.getBalance(dest);
        // Prepare
        let prepared = await treasure.wallet.prepareTransfer({
            to: dest,
            value: 0.001,
            bounceable: false
        });
        // Sign
        let signed = await treasure.wallet.signTransfer(prepared, treasure.secretKey);
        // Send
        await treasure.wallet.sendTransfer(signed);
        while (true) {
            await (0, time_1.delay)(1000);
            if (await client.getBalance(dest) > balance) {
                break;
            }
        }
    });
});

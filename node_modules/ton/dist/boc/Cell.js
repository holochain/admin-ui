"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cell = void 0;
const BitString_1 = require("./BitString");
const boc_1 = require("./boc");
class Cell {
    static fromBoc(src) {
        return (0, boc_1.deserializeBoc)(typeof src === 'string' ? Buffer.from(src, 'hex') : src);
    }
    bits = BitString_1.BitString.alloc(1023);
    refs = [];
    isExotic;
    constructor(isExotic = false) {
        this.isExotic = isExotic;
    }
    writeCell(anotherCell) {
        this.bits.writeBitString(anotherCell.bits);
        for (let r of anotherCell.refs) {
            this.refs.push(r);
        }
    }
    hash() {
        return (0, boc_1.hashCell)(this);
    }
    toBoc(opts) {
        let idx = (opts && opts.idx !== null && opts.idx !== undefined) ? opts.idx : true;
        let crc32 = (opts && opts.crc32 !== null && opts.crc32 !== undefined) ? opts.crc32 : true;
        let cacheBits = (opts && opts.cacheBits !== null && opts.cacheBits !== undefined) ? opts.cacheBits : false;
        let flags = (opts && opts.flags !== null && opts.flags !== undefined) ? opts.flags : 0;
        return (0, boc_1.serializeToBoc)(this, idx, crc32, cacheBits, flags);
    }
    toString(indent) {
        let id = indent || '';
        let s = id + 'x{' + this.bits.toFiftHex() + '}\n';
        for (let k in this.refs) {
            const i = this.refs[k];
            s += i.toString(id + ' ');
        }
        return s;
    }
}
exports.Cell = Cell;

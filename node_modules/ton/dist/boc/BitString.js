"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitString = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
class BitString {
    static alloc(length) {
        return new BitString(Buffer.alloc(Math.ceil(length / 8), 0), length, 0);
    }
    #length;
    #cursor;
    #buffer;
    constructor(buffer, length, cursor) {
        this.#buffer = buffer;
        this.#length = length;
        this.#cursor = cursor;
    }
    get available() {
        return this.length - this.cursor;
    }
    get length() {
        return this.#length;
    }
    get cursor() {
        return this.#cursor;
    }
    get buffer() {
        return this.#buffer;
    }
    [Symbol.iterator] = () => {
        let offset = 0;
        let end = this.#cursor;
        return {
            next: () => {
                if (offset < end) {
                    let v = this.get(offset);
                    offset++;
                    return {
                        done: false,
                        value: v
                    };
                }
                else {
                    return {
                        done: true
                    };
                }
            }
        };
    };
    get = (n) => {
        this.#checkRange(n);
        return (this.#buffer[(n / 8) | 0] & (1 << (7 - (n % 8)))) > 0;
    };
    on = (n) => {
        this.#checkRange(n);
        this.#buffer[(n / 8) | 0] |= 1 << (7 - (n % 8));
    };
    off = (n) => {
        this.#checkRange(n);
        this.#buffer[(n / 8) | 0] &= ~(1 << (7 - (n % 8)));
    };
    toggle = (n) => {
        this.#checkRange(n);
        this.#buffer[(n / 8) | 0] ^= 1 << (7 - (n % 8));
    };
    writeBit = (value) => {
        if (value === true || value > 0) {
            this.on(this.#cursor);
        }
        else {
            this.off(this.#cursor);
        }
        this.#cursor++;
    };
    writeBitArray(value) {
        for (let v of value) {
            this.writeBit(v);
        }
    }
    writeUint(value, bitLength) {
        let v = new bn_js_1.default(value);
        if (bitLength == 0 || (value.toString(2).length > bitLength)) {
            if (v.isZero()) {
                return;
            }
            throw Error(`bitLength is too small for a value ${v.toString()}. Got ${bitLength}, expected >= ${value.toString(2).length}`);
        }
        const s = v.toString(2, bitLength);
        for (let i = 0; i < bitLength; i++) {
            this.writeBit(s[i] === '1');
        }
    }
    writeInt(value, bitLength) {
        let v = new bn_js_1.default(value);
        if (bitLength == 1) {
            if (v.eq(new bn_js_1.default(-1))) {
                this.writeBit(true);
                return;
            }
            if (v.isZero()) {
                this.writeBit(false);
                return;
            }
            throw Error(`bitlength is too small for a value ${v}`);
        }
        else {
            if (v.isNeg()) {
                this.writeBit(true);
                const b = new bn_js_1.default(2);
                const nb = b.pow(new bn_js_1.default(bitLength - 1));
                this.writeUint(nb.add(v), bitLength - 1);
            }
            else {
                this.writeBit(false);
                this.writeUint(v, bitLength - 1);
            }
        }
    }
    writeUint8(value) {
        this.writeUint(value, 8);
    }
    writeBuffer(buffer) {
        for (let i = 0; i < buffer.length; i++) {
            this.writeUint8(buffer[i]);
        }
    }
    writeString(s) {
        for (let i = 0; i < s.length; i++) {
            this.writeUint8(s.charCodeAt(i));
        }
    }
    writeGrams(amount) {
        if (amount == 0) {
            this.writeUint(0, 4);
        }
        else {
            amount = new bn_js_1.default(amount);
            const l = Math.ceil((amount.toString(16).length) / 2);
            this.writeUint(l, 4);
            this.writeUint(amount, l * 8);
        }
    }
    writeAddress(address) {
        if (address === null) {
            this.writeUint(0, 2);
        }
        else {
            this.writeUint(2, 2);
            this.writeUint(0, 1);
            this.writeInt(address.workChain, 8);
            this.writeBuffer(address.hash);
        }
    }
    writeBitString(value) {
        for (let v of value) {
            this.writeBit(v);
        }
    }
    clone() {
        return new BitString(this.#buffer.slice(0), this.#length, this.#cursor);
    }
    toString() {
        let res = '';
        for (let v of this) {
            if (v) {
                res = res + '1';
            }
            else {
                res = res + '0';
            }
        }
        return res;
    }
    toFiftHex() {
        if (this.cursor % 4 === 0) {
            const s = this.#buffer.slice(0, Math.ceil(this.cursor / 8)).toString('hex').toUpperCase();
            if (this.cursor % 8 === 0) {
                return s;
            }
            else {
                return s.substr(0, s.length - 1);
            }
        }
        else {
            const temp = this.clone();
            temp.writeBit(1);
            while (temp.cursor % 4 !== 0) {
                temp.writeBit(0);
            }
            const hex = temp.toFiftHex().toUpperCase();
            return hex + '_';
        }
    }
    setTopUppedArray(array, fullfilledBytes = true) {
        this.#length = array.length * 8;
        this.#buffer = array;
        this.#cursor = this.length;
        if (fullfilledBytes || !this.length) {
            return;
        }
        else {
            let foundEndBit = false;
            for (let c = 0; c < 7; c++) {
                this.#cursor -= 1;
                if (this.get(this.cursor)) {
                    foundEndBit = true;
                    this.off(this.cursor);
                    break;
                }
            }
            if (!foundEndBit) {
                console.log(array, fullfilledBytes);
                throw new Error("Incorrect TopUppedArray");
            }
        }
    }
    getTopUppedArray() {
        const ret = this.clone();
        let tu = Math.ceil(ret.cursor / 8) * 8 - ret.cursor;
        if (tu > 0) {
            tu = tu - 1;
            ret.writeBit(true);
            while (tu > 0) {
                tu = tu - 1;
                ret.writeBit(false);
            }
        }
        ret.#buffer = ret.#buffer.slice(0, Math.ceil(ret.cursor / 8));
        return ret.#buffer;
    }
    //
    // Helpers
    //
    #checkRange(n) {
        if (n > this.length) {
            throw Error('Invalid index: ' + n);
        }
    }
}
exports.BitString = BitString;

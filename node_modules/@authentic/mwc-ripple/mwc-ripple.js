var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
import { LitElement, html, property, customElement, classMap } from '@authentic/mwc-base/base-element';
import { ripple } from './ripple-directive';
import { style } from './mwc-ripple-css';
let Ripple = class Ripple extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * Optional. Default value sets to false. To use the primary color of the ripple effect.
         */
        this.primary = false;
        /**
         * Optional. Default value sets to false. To use the secondary color of the ripple effect.
         */
        this.accent = false;
        /**
         * Optional. Default value sets to false. Sets the ripple to be unbounded or not, based on the given boolean.
         */
        this.unbounded = false;
        /**
         * Optional. Default value sets to false. Makes the ripple inactive and inaccessible via interaction.
         */
        this.disabled = false;
        this.interactionNode = this;
    }
    /**
     * Invoked each time the custom element is appended into the DOM.
     * This will happen each time the node is moved, and may happen before the element's contents have been fully parsed
     */
    connectedCallback() {
        if (this.interactionNode === this) {
            this.interactionNode = this.parentNode;
        }
        super.connectedCallback();
    }
    // TODO(sorvell) #css: sizing.
    /**
     * Used to render the lit-html TemplateResult to the element's DOM
     */
    render() {
        const classes = {
            'mdc-ripple-surface--primary': this.primary,
            'mdc-ripple-surface--accent': this.accent,
        };
        const { disabled, unbounded, active, interactionNode } = this;
        const rippleOptions = { disabled, unbounded, interactionNode };
        if (active !== undefined) {
            rippleOptions.active = active;
        }
        return html `
      <div .ripple="${ripple(rippleOptions)}" class="mdc-ripple-surface ${classMap(classes)}"></div>`;
    }
};
Ripple.styles = style;
__decorate([
    property({ type: Boolean })
], Ripple.prototype, "primary", void 0);
__decorate([
    property({ type: Boolean })
], Ripple.prototype, "active", void 0);
__decorate([
    property({ type: Boolean })
], Ripple.prototype, "accent", void 0);
__decorate([
    property({ type: Boolean })
], Ripple.prototype, "unbounded", void 0);
__decorate([
    property({ type: Boolean })
], Ripple.prototype, "disabled", void 0);
__decorate([
    property()
], Ripple.prototype, "interactionNode", void 0);
Ripple = __decorate([
    customElement('mwc-ripple')
], Ripple);
export { Ripple };
//# sourceMappingURL=mwc-ripple.js.map
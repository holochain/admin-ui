{"version":3,"sources":[" [synthetic:es6/util/arrayiterator] ","src/scoped-custom-element-registry.js"," [synthetic:es6/util/makeiterator] "],"names":["ShadowRoot","prototype","createElement","NativeHTMLElement","window","HTMLElement","nativeDefine","customElements","define","nativeGet","get","nativeRegistry","definitionForElement","WeakMap","pendingRegistryForElement","globalDefinitionForConstructor","scopeForElement","CustomElementRegistry","constructor","_definitionsByTag","Map","_definitionsByClass","_whenDefinedPromises","_awaitingUpgrade","tagName","elementClass","toLowerCase","undefined","_getDefinition","DOMException","attributeChangedCallback","observedAttributes","Set","patchAttributes","definition","connectedCallback","disconnectedCallback","adoptedCallback","set","standInClass","call","createStandInElement","awaiting","delete","$jscomp.arrayIteratorImpl","element","customize","info","resolve","upgrade","creationContext","push","apply","arguments","pop","whenDefined","Promise","promise","r","_upgradeWhenDefined","shouldUpgrade","add","upgradingInstance","window.HTMLElement","instance","TypeError","Reflect","construct","Object","setPrototypeOf","scope","getRootNode","document","context","length","registry","size","setAttribute","elementClass.prototype.setAttribute","name","value","has","old","getAttribute","removeAttribute","elementClass.prototype.removeAttribute","patchHTMLElement","parentClass","getPrototypeOf","isUpgrade","_","forEach","attr","hasAttribute","isConnected","nativeAttachShadow","Element","attachShadow","Element.prototype.attachShadow","init","shadowRoot","installScopedCreationMethod","ctor","method","from","native","ret","installScopedCreationSetter","descriptor","getOwnPropertyDescriptor","defineProperty","configurable","writable"],"mappings":"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","file":"scoped-custom-element-registry.min.js","sourcesContent":[null,"/**\n * @license\n * Copyright (c) 2020 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nif (!ShadowRoot.prototype.createElement) {\n  const NativeHTMLElement = window.HTMLElement;\n  const nativeDefine = window.customElements.define;\n  const nativeGet = window.customElements.get;\n  const nativeRegistry = window.customElements;\n\n  const definitionForElement = new WeakMap();\n  const pendingRegistryForElement = new WeakMap();\n  const globalDefinitionForConstructor = new WeakMap();\n  // TBD: This part of the spec proposal is unclear:\n  // > Another option for looking up registries is to store an element's\n  // > originating registry with the element. The Chrome DOM team was concerned\n  // > about the small additional memory overhead on all elements. Looking up the\n  // > root avoids this.\n  const scopeForElement = new WeakMap();\n\n  // Constructable CE registry class, which uses the native CE registry to\n  // register stand-in elements that can delegate out to CE classes registered\n  // in scoped registries\n  window.CustomElementRegistry = class {\n    constructor() {\n      this._definitionsByTag = new Map();\n      this._definitionsByClass = new Map();\n      this._whenDefinedPromises = new Map();\n      this._awaitingUpgrade = new Map();\n    }\n\n    define(tagName, elementClass) {\n      tagName = tagName.toLowerCase();\n      if (this._getDefinition(tagName) !== undefined) {\n        throw new DOMException(\n          `Failed to execute 'define' on 'CustomElementRegistry': the name \"${tagName}\" has already been used with this registry`\n        );\n      }\n      if (this._definitionsByClass.get(elementClass) !== undefined) {\n        throw new DOMException(\n          `Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry`\n        );\n      }\n      // Since observedAttributes can't change, we approximate it by patching\n      // set/removeAttribute on the user's class\n      const attributeChangedCallback =\n        elementClass.prototype.attributeChangedCallback;\n      const observedAttributes = new Set(elementClass.observedAttributes || []);\n      patchAttributes(\n        elementClass,\n        observedAttributes,\n        attributeChangedCallback\n      );\n      // Register the definition\n      const definition = {\n        elementClass,\n        connectedCallback: elementClass.prototype.connectedCallback,\n        disconnectedCallback: elementClass.prototype.disconnectedCallback,\n        adoptedCallback: elementClass.prototype.adoptedCallback,\n        attributeChangedCallback,\n        observedAttributes,\n      };\n      this._definitionsByTag.set(tagName, definition);\n      this._definitionsByClass.set(elementClass, definition);\n      // Register a stand-in class which will handle the registry lookup & delegation\n      let standInClass = nativeGet.call(nativeRegistry, tagName);\n      if (!standInClass) {\n        standInClass = createStandInElement(tagName);\n        nativeDefine.call(nativeRegistry, tagName, standInClass);\n      }\n      if (this === window.customElements) {\n        globalDefinitionForConstructor.set(elementClass, definition);\n        definition.standInClass = standInClass;\n      }\n      // Upgrade any elements created in this scope before define was called\n      const awaiting = this._awaitingUpgrade.get(tagName);\n      if (awaiting) {\n        this._awaitingUpgrade.delete(tagName);\n        for (const element of awaiting) {\n          pendingRegistryForElement.delete(element);\n          customize(element, definition, true);\n        }\n      }\n      // Flush whenDefined callbacks\n      const info = this._whenDefinedPromises.get(tagName);\n      if (info !== undefined) {\n        info.resolve(elementClass);\n        this._whenDefinedPromises.delete(tagName);\n      }\n      return elementClass;\n    }\n\n    upgrade() {\n      creationContext.push(this);\n      nativeRegistry.upgrade.apply(nativeRegistry, arguments);\n      creationContext.pop();\n    }\n\n    get(tagName) {\n      const definition = this._definitionsByTag.get(tagName);\n      return definition?.elementClass;\n    }\n\n    _getDefinition(tagName) {\n      return this._definitionsByTag.get(tagName);\n    }\n\n    whenDefined(tagName) {\n      const definition = this._getDefinition(tagName);\n      if (definition !== undefined) {\n        return Promise.resolve(definition.elementClass);\n      }\n      let info = this._whenDefinedPromises.get(tagName);\n      if (info === undefined) {\n        info = {};\n        info.promise = new Promise((r) => (info.resolve = r));\n        this._whenDefinedPromises.set(tagName, info);\n      }\n      return info.promise;\n    }\n\n    _upgradeWhenDefined(element, tagName, shouldUpgrade) {\n      let awaiting = this._awaitingUpgrade.get(tagName);\n      if (!awaiting) {\n        this._awaitingUpgrade.set(tagName, (awaiting = new Set()));\n      }\n      if (shouldUpgrade) {\n        awaiting.add(element);\n      } else {\n        awaiting.delete(element);\n      }\n    }\n  };\n\n  // User extends this HTMLElement, which returns the CE being upgraded\n  let upgradingInstance;\n  window.HTMLElement = function HTMLElement() {\n    // Upgrading case: the StandInElement constructor was run by the browser's\n    // native custom elements and we're in the process of running the\n    // \"constructor-call trick\" on the natively constructed instance, so just\n    // return that here\n    let instance = upgradingInstance;\n    if (instance) {\n      upgradingInstance = undefined;\n      return instance;\n    }\n    // Construction case: we need to construct the StandInElement and return\n    // it; note the current spec proposal only allows new'ing the constructor\n    // of elements registered with the global registry\n    const definition = globalDefinitionForConstructor.get(this.constructor);\n    if (!definition) {\n      throw new TypeError(\n        'Illegal constructor (custom element class must be registered with global customElements registry to be newable)'\n      );\n    }\n    instance = Reflect.construct(\n      NativeHTMLElement,\n      [],\n      definition.standInClass\n    );\n    Object.setPrototypeOf(instance, this.constructor.prototype);\n    definitionForElement.set(instance, definition);\n    return instance;\n  };\n  window.HTMLElement.prototype = NativeHTMLElement.prototype;\n\n  // Helpers to return the scope for a node where its registry would be located\n  const isValidScope = (node) =>\n    node === document || node instanceof ShadowRoot;\n  const registryForNode = (node) => {\n    // TODO: the algorithm for finding the scope is a bit up in the air; assigning\n    // a one-time scope at creation time would require walking every tree ever\n    // created, which is avoided for now\n    let scope = node.getRootNode();\n    // If we're not attached to the document (i.e. in a disconnected tree or\n    // fragment), we need to get the scope from the creation context; that should\n    // be a Document or ShadowRoot, unless it was created via innerHTML\n    if (!isValidScope(scope)) {\n      const context = creationContext[creationContext.length - 1];\n      // When upgrading via registry.upgrade(), the registry itself is put on the\n      // creationContext stack\n      if (context instanceof CustomElementRegistry) {\n        return context;\n      }\n      // Otherwise, get the root node of the element this was created from\n      scope = context.getRootNode();\n      // The creation context wasn't a Document or ShadowRoot or in one; this\n      // means we're being innerHTML'ed into a disconnected element; for now, we\n      // hope that root node was created imperatively, where we stash _its_\n      // scopeForElement. Beyond that, we'd need more costly tracking.\n      if (!isValidScope(scope)) {\n        scope = scopeForElement.get(scope)?.getRootNode() || document;\n      }\n    }\n    return scope.customElements;\n  };\n\n  // Helper to create stand-in element for each tagName registered that delegates\n  // out to the registry for the given element\n  const createStandInElement = (tagName) => {\n    return class ScopedCustomElementBase {\n      constructor() {\n        // Create a raw HTMLElement first\n        const instance = Reflect.construct(\n          NativeHTMLElement,\n          [],\n          this.constructor\n        );\n        // We need to install the minimum HTMLElement prototype so that\n        // scopeForNode can use DOM API to determine our construction scope;\n        // upgrade will eventually install the full CE prototype\n        Object.setPrototypeOf(instance, HTMLElement.prototype);\n        // Get the node's scope, and its registry (falls back to global registry)\n        const registry = registryForNode(instance) || window.customElements;\n        const definition = registry._getDefinition(tagName);\n        if (definition) {\n          customize(instance, definition);\n        } else {\n          pendingRegistryForElement.set(instance, registry);\n        }\n        return instance;\n      }\n\n      connectedCallback() {\n        const definition = definitionForElement.get(this);\n        if (definition) {\n          // Delegate out to user callback\n          definition.connectedCallback &&\n            definition.connectedCallback.apply(this, arguments);\n        } else {\n          // Register for upgrade when defined (only when connected, so we don't leak)\n          pendingRegistryForElement\n            .get(this)\n            ._upgradeWhenDefined(this, tagName, true);\n        }\n      }\n\n      disconnectedCallback() {\n        const definition = definitionForElement.get(this);\n        if (definition) {\n          // Delegate out to user callback\n          definition.disconnectedCallback &&\n            definition.disconnectedCallback.apply(this, arguments);\n        } else {\n          // Un-register for upgrade when defined (so we don't leak)\n          pendingRegistryForElement\n            .get(this)\n            ._upgradeWhenDefined(this, tagName, false);\n        }\n      }\n\n      adoptedCallback() {\n        const definition = definitionForElement.get(this);\n        definition?.adoptedCallback?.apply(this, arguments);\n      }\n\n      // no attributeChangedCallback or observedAttributes since these\n      // are simulated via setAttribute/removeAttribute patches\n    };\n  };\n\n  // Helper to patch CE class setAttribute/getAttribute to implement\n  // attributeChangedCallback\n  const patchAttributes = (\n    elementClass,\n    observedAttributes,\n    attributeChangedCallback\n  ) => {\n    if (\n      observedAttributes.size === 0 ||\n      attributeChangedCallback === undefined\n    ) {\n      return;\n    }\n    const setAttribute = elementClass.prototype.setAttribute;\n    if (setAttribute) {\n      elementClass.prototype.setAttribute = function (name, value) {\n        if (observedAttributes.has(name)) {\n          const old = this.getAttribute(name);\n          setAttribute.call(this, name, value);\n          attributeChangedCallback.call(this, name, old, value);\n        } else {\n          setAttribute.call(this, name, value);\n        }\n      };\n    }\n    const removeAttribute = elementClass.prototype.removeAttribute;\n    if (removeAttribute) {\n      elementClass.prototype.removeAttribute = function (name) {\n        if (observedAttributes.has(name)) {\n          const old = this.getAttribute(name);\n          removeAttribute.call(this, name);\n          attributeChangedCallback.call(this, name, old, null);\n        } else {\n          removeAttribute.call(this, name);\n        }\n      };\n    }\n  };\n\n  // Helper to patch CE class hierarchy changing those CE classes created before applying the polyfill\n  // to make them work with the new patched CustomElementsRegistry\n  const patchHTMLElement = (elementClass) => {\n    const parentClass = Object.getPrototypeOf(elementClass);\n\n    if (parentClass !== window.HTMLElement) {\n      if (parentClass === NativeHTMLElement) {\n        return Object.setPrototypeOf(elementClass, window.HTMLElement);\n      }\n\n      return patchHTMLElement(parentClass);\n    }\n  };\n\n  // Helper to upgrade an instance with a CE definition using \"constructor call trick\"\n  const customize = (instance, definition, isUpgrade = false) => {\n    Object.setPrototypeOf(instance, definition.elementClass.prototype);\n    definitionForElement.set(instance, definition);\n    upgradingInstance = instance;\n    try {\n      new definition.elementClass();\n    } catch (_) {\n      patchHTMLElement(definition.elementClass);\n      new definition.elementClass();\n    }\n    // Approximate observedAttributes from the user class, since the stand-in element had none\n    definition.observedAttributes.forEach((attr) => {\n      if (instance.hasAttribute(attr)) {\n        definition.attributeChangedCallback.call(\n          instance,\n          attr,\n          null,\n          instance.getAttribute(attr)\n        );\n      }\n    });\n    if (isUpgrade && definition.connectedCallback && instance.isConnected) {\n      definition.connectedCallback.call(instance);\n    }\n  };\n\n  // Patch attachShadow to set customElements on shadowRoot when provided\n  const nativeAttachShadow = Element.prototype.attachShadow;\n  Element.prototype.attachShadow = function (init) {\n    const shadowRoot = nativeAttachShadow.apply(this, arguments);\n    if (init.customElements) {\n      shadowRoot.customElements = init.customElements;\n    }\n    return shadowRoot;\n  };\n\n  // Install scoped creation API on Element & ShadowRoot\n  let creationContext = [document];\n  const installScopedCreationMethod = (ctor, method, from = undefined) => {\n    const native = (from ? Object.getPrototypeOf(from) : ctor.prototype)[\n      method\n    ];\n    ctor.prototype[method] = function () {\n      creationContext.push(this);\n      const ret = native.apply(from || this, arguments);\n      // For disconnected elements, note their creation scope so that e.g.\n      // innerHTML into them will use the correct scope; note that\n      // insertAdjacentHTML doesn't return an element, but that's fine since\n      // it will have a parent that should have a scope\n      if (ret !== undefined) {\n        scopeForElement.set(ret, this);\n      }\n      creationContext.pop();\n      return ret;\n    };\n  };\n  installScopedCreationMethod(ShadowRoot, 'createElement', document);\n  installScopedCreationMethod(ShadowRoot, 'importNode', document);\n  installScopedCreationMethod(Element, 'insertAdjacentHTML');\n\n  // Install scoped innerHTML on Element & ShadowRoot\n  const installScopedCreationSetter = (ctor, name) => {\n    const descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, name);\n    Object.defineProperty(ctor.prototype, name, {\n      ...descriptor,\n      set(value) {\n        creationContext.push(this);\n        descriptor.set.call(this, value);\n        creationContext.pop();\n      },\n    });\n  };\n  installScopedCreationSetter(Element, 'innerHTML');\n  installScopedCreationSetter(ShadowRoot, 'innerHTML');\n\n  // Install global registry\n  Object.defineProperty(window, 'customElements', {\n    value: new CustomElementRegistry(),\n    configurable: true,\n    writable: true,\n  });\n}\n"]}